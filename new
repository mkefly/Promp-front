# **AI-Product API Architecture — Evaluation & Serving (API-Only, No Hot Reload)**

**Scope:** Define the **AI-Product API** as the **only runtime workload** of an AI-Product. All models exist **only** as **Unity Catalog/MLflow registrations** (families, versions, aliases). The API **resolves and materializes** models **once at startup** (no hot reload) under a **strict stage policy**. Each AI-Product has **two namespaces** — **Evaluation** and **Serving** — each with **one UAMI** and clearly separated ingress/egress, evidence, and MRMC promotion.

> **Edge Authorization Options (reading guide)**
> Choose one at the product edge:
> **Azure API Management (APIM) Self-Hosted Gateway** in front of Istio.


---

## 0) Executive Summary

An **AI-Product** is the **smallest governed runtime boundary** in AIMART’s AKS platform. It encapsulates one or more **APIs** (each API loads Unity Catalog models at startup) and treats them as a **single product unit** for compliance, identity, risk, audit, and operations.

Key characteristics or an AI-product:

* **Shared Identity** — one Entra ID (AAD) group set, one UAMI.
* **Shared Risk Profile** — one MRMC classification (PII class, residency, retention).
* **Shared Data Scope** — one Unity Catalog schema (models, experiments, artifacts).
* **Shared Networking Rules** — one Istio ingress/egress boundary.
* **Shared Audit Trail** — one tamper-evident evidence bundle.
* **Shared Operations** — one SLO/SLA, one incident response playbook.

Key characteristics of these flavor:

* **API-only runtime**: The **Developer API** is the sole deployed workload per stage.
* **Models are not deployed**: they are **registrations** in Unity Catalog/MLflow and are **fetched at startup** by alias.
* **Two namespaces**:

  * **Evaluation** (`ai-product-eval`, `UAMI-EVAL`): **Auditor/Evaluator ingress only**, **read-only egress**, admitted aliases = `evaluation|shadow|candidate`.
  * **Serving** (`ai-product-serve`, `UAMI-SERVE`): **Consumer + A2A ingress**, governed egress to prod sources, admitted alias = `production`.
* **Optional Teams**: API can be **registered with Azure Bot Service** and expose **`/api/messages`**; there is **no bot pod**.
* **No Hot Reload**: alias changes in UC **require a redeploy**; the API does **not** live-swap models.
* **Evidence**: APIM decisions + API startup alias-conformance/materialization records → **Stage bundle** (Eval/Serve) → **AI-Product bundle**.

---

## 2) Decision

Define an **AI-Product** as:

* One or two **namespaces** in AKS (Eval + Serve).
* One **shared Entra ID group model + UAMI per stage**.
* One **MRMC profile**.
* One **Unity Catalog schema**.
* One **ingress/egress boundary**.
* One **audit bundle**.
* One **Ops envelope (SLO/SLA + on-call)**.

> **Terminology note — “Model”**
> A model can be (1) a classic AI/ML model or (2) a modern agent (LLM-based, tool-using/orchestrating). Both are treated identically inside the AI-Product across identity/RBAC, MRMC, networking, SLOs, and audit. Extended tracing is guaranteed when accessing external APIs (e.g., OpenAI).

---

## 3) Stage Model

**One AI-Product → Two namespaces; API-only runtime; single UAMI per stage; strict alias admission; no hot reload.**

| Stage      | Namespace          | UAMI         | Admitted Aliases                       | Ingress (APIM→Istio)                        | Egress (Istio Egress GW)                                                                                 |
| ---------- | ------------------ | ------------ | -------------------------------------- | ------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| Evaluation | `ai-product-eval`  | `UAMI-EVAL`  | `@evaluation-*` | **Auditors/Evaluators only** (no Consumers) | UC **read**, DataMesh **read (test)**, observability; optional **shadow** sources; **no prod writes**    |
| Serving    | `ai-product-serve` | `UAMI-SERVE` | `@production-*`                          | **Consumers + A2A**                         | UC read, DataMesh **read/write (prod)**, **Kafka A2A topics**, observability; others **deny** by default |

**Hard rules**

1. **Exactly one UAMI per stage**.
2. **Alias conformance** is **mandatory**. The API **must refuse** to load any model whose alias is not admitted for the stage.

---

## 4) Runtime Model (API-Only)

**What runs:** A **Developer-built API container** per stage (optionally exposing `/api/messages` for Teams).
**Model Families:** Defined as a model registry entry **in Unity Catalog** AI-product schema with (versions, aliases, lineage, artifacts, evaluation evidence).

**API responsibilities**

1. **Alias Gate at Startup (hard-fail).**
2. **Resolve & Fetch** artifacts from UC.
3. **Emit Evidence on Startup** (alias-conformance + materialization).
4. **Least Privilege** via UAMI-scoped permissions.
5. **Single Ingress Channel** (APIM→Istio).

---

## 2) Rationale & Consequences

**Why this model works**

* **Stage separation** — Evaluation remains controlled and observable for auditors, while Serving stays streamlined for consumers and A2A integration.
* **Developer autonomy** — Teams can design richer APIs (batch, async, Teams integration) without being constrained by a fixed serving stack.
* **Evidence consolidation** — Startup checks, ingress policies, and runtime decisions are captured in one place, producing a clean, tamper-evident audit trail.

**Trade-offs and obligations**

* **Alias enforcement** — APIs must strictly reject models not admitted for the stage; otherwise compliance boundaries collapse.
* **Ingress/Egress governance** — Network rules must be precisely defined, with default-deny enforced and allowlists approved through MRMC.
* **Shared responsibility model** — Owners, engineers, and auditors need clear accountability for gates (startup alias checks, MRMC promotion, CI/CD drift guards).
* **Operational overhead** — Two namespaces (Eval/Serve) introduce more moving parts; strong cookbook adherence is required to keep operations consistent.

---

# Part I — Principles

## 3) Runtime Model (API-Only)

**What runs:** A **Developer-built API container** per stage (optionally exposing `/api/messages` for Teams via ABS).
**Model Families:** Exist **only in Unity Catalog/MLflow** (versions, aliases, lineage, artifacts, evaluation evidence).

**API responsibilities**

1. **Alias Gate at Startup (hard-fail):**
   Read stage policy → resolve `{family, alias}` in UC → verify alias admission for the stage → **exit non-zero** on any mismatch.
2. **Resolve & Fetch:**
   Map alias → concrete version; download artifacts (env, weights, tokenizer, etc.); verify checksums/signatures; materialize in memory/runtime.
3. **Evidence on Startup:**
   Emit a signed (or hashed) **alias-conformance & materialization record** (families, aliases, resolved versions, digests, policy id).
4. **Least Privilege:**
   Use only the UC/DataMesh permissions authorized for the stage and bound to the stage UAMI.
5. **Single Ingress Channel:**
   All traffic enters via **APIM → Istio**. No side doors (NodePort/LoadBalancer/ClusterIP bypasses).

**Stage policies**

```yaml
# ai-product-eval
stage: evaluation
allowed_aliases: [evaluation-*]
deny_on_mismatch: true
```

```yaml
# ai-product-serve
stage: serving
allowed_aliases: [production-*]
deny_on_mismatch: true
```

**Startup denial example**

```
requested_models:
  - family: RiskScorer
    alias: evaluation-v1
stage: serving
decision: DENY (alias 'evaluation-v1' not admitted in serving stage)
action: exit(1)
```

---

## 4) API Surface (recommended)

* **ASync/Sync inference:** `POST /predict`
* **Batch/async (optional):** `POST /batch` → job id; `GET /batch/{id}`
* **Health:** `GET /healthz`, `GET /readyz`
* **Teams webhook (optional):** `POST /api/messages` (Bot Framework, handled by your API)
* **Admin/metadata:** exposed by **Info-Ports** (operator pod), not by the API:

  * `/info/agent`, `/info/model-card`, `/info/aibom` (APIM Viewer group)

**APIM routing sketch**

```
^/api/messages$                     → API (Teams via ABS)
^/(predict|batch|healthz|readyz)$   → API
^/info/(agent|model-card|aibom)$    → Info-Ports
```

---

## 5) Identity & RBAC (per stage)

* **One UAMI per stage**; all K8s SAs federate to that UAMI (Option B).
* CI/CD renders expected FIC subjects; **fail on drift**.

| Group     | Evaluation                   | Serving                       |
| --------- | ---------------------------- | ----------------------------- |
| Owner     | Full admin                   | Full admin                    |
| Engineer  | Deploy API, manage config    | Deploy API, manage config     |
| Developer | Experiments, offline tests   | N/A or limited                |
| Consumer  | N/A                          | Invoke inference              |
| Auditor   | Access eval evidence/metrics | Access serve evidence/metrics |

---

## 6) Networking & Access

**Ingress (both stages):**
APIM (JWT, roles/groups, quotas) → Istio IngressGateway → API / Info-Ports.

* **Evaluation**: only **Auditor/Evaluator** APIM products.
* **Serving**: **Consumers + A2A** APIM products.

**Internal mesh:**

* API only + Info-Ports (operator).
* No inter-API calls unless explicitly allowed (AuthorizationPolicy + ServiceEntries).

**Egress:**

* **Evaluation:** UC read, DataMesh read(test), observability, optional “shadow” sources; deny everything else.
* **Serving:** UC, DataMesh (prod R/W), Kafka A2A topics, observability; deny others unless MRMC-approved.

---

## 7) Info-Ports Pod (operator-owned)

* **/info/agent** — stage, UAMI, API metadata (for cards).
* **/info/model-card** — “what is materialized now” (families, aliases, versions, digests).
* **/info/aibom** — stage AI-BOM (models + transitive tools).
* **Security:** APIM Viewer group. **Separation:** keeps governance surfaces stable and decoupled from API code.

---

## 8) Kafka A2A

* **Serving**: use whitelisted topics (e.g., `product.{id}.serve.in/out`), headers: `product_id, stage, uami_id, request_id`.
* **Evaluation**: optional eval topics; **no prod fan-out**.

---

# Part II — Diagrams

## A) Topology (API-only)

```mermaid
flowchart LR
  APIM[APIM Self-Hosted Gateway<br/>JWT · Groups/Roles · Quotas] --> IGW[Istio IngressGateway]

  subgraph EVAL[AI-Product-Eval · Namespace]
    APIE[Developer API<br/>aliases=evaluation,shadow,candidate]
    INFOE[Info-Ports Pod]
    UAMIE[UAMI-EVAL]
  end

  subgraph SERVE[AI-Product-Serve · Namespace]
    APIS[Developer API<br/>aliases=production]
    INFOS[Info-Ports Pod]
    UAMIS[UAMI-SERVE]
  end

  APIM --> IGW --> APIE
  APIM --> IGW --> APIS
  APIM --> IGW --> INFOE
  APIM --> IGW --> INFOS

  APIE --> UC[Unity Catalog / MLflow]
  APIS --> UC
  EVAL --> DMTEST[DataMesh test, read-only]
  SERVE --> DM[DataMesh prod R/W]
  SERVE --> KAF[Kafka A2A topics]
  EVAL --> OBS[Observability]
  SERVE --> OBS
```

---

## B) **Teams via Azure Bot Service** → APIM → Istio → **API** 

```mermaid
sequenceDiagram
  autonumber
  participant Teams as Microsoft Teams Client
  participant ABS as Azure Bot Service (Cloud)
  participant APIM as APIM SHGW (edge)
  participant IGW as Istio IngressGateway
  participant API as AI-Product API (/api/messages)

  Teams->>ABS: Send message (Bot Framework)
  ABS->>APIM: POST /api/messages (BF JWT)
  APIM->>APIM: Validate JWT (iss/aud/sig) + policy (groups/roles/quotas)
  alt Allowed
    APIM->>IGW: Forward (pre-authorized)
    IGW->>API: /api/messages
    API-->>ABS: 200 + activity
    ABS-->>Teams: Deliver response
  else Denied
    APIM-->>ABS: 401/403
  end
```

---

## C) **Consumer** → APIM → Istio → **API**

```mermaid
sequenceDiagram
  autonumber
  participant U as Consumer (AAD App/User)
  participant APIM as APIM SHGW
  participant IGW as Istio IngressGateway
  participant API as AI-Product API

  U->>APIM: POST /predict (Bearer AAD token)
  APIM->>APIM: Validate JWT + quotas + groups/roles
  alt Allowed
    APIM->>IGW: Forward
    IGW->>API: POST /predict
    API-->>U: 200 {prediction, trace_id}
  else Denied
    APIM-->>U: 401/403
  end
```

---

## D) **A2A (Kafka)** — Serving stage

```mermaid
sequenceDiagram
  autonumber
  participant A2A as Producer/Consumer (UAMI-SERVE)
  participant K as Kafka Cluster (allowed topics)

  A2A->>K: Produce/Consume on whitelisted topics
  Note over A2A,K: Headers: product_id, stage, uami_id, request_id\nACLs & retention meet MRMC policy
```

---



---

## F) **Promotion** Eval → Serve (MRMC-gated)

```mermaid
sequenceDiagram
  autonumber
  participant APIE as API (Eval)
  participant MR as MRMC Gate
  participant CI as CI/CD
  participant APIS as API (Serve)

  APIE->>MR: Submit evidence (metrics, safety, lineage, eval datasets)
  MR->>MR: Assess risk/PII/residency + required controls
  alt Approved
    MR->>CI: Approve promotion
    CI->>APIS: Deploy Serve image + policy {allowed_aliases:[production]}
    APIS->>UC: Resolve production aliases
    APIS->>APIS: Verify + materialize
    APIS-->>CI: Ready
  else Rejected
    MR-->>APIE: Findings + remediation steps
  end
```

---

# Part III — Operations

## 9) CI/CD Guardrails

* **Build**: SBOM, signatures, image digest pinning.
* **Deploy**:

  * Inject `stage` + `aliasPolicy` + `uamiClientId` via Helm.
  * Render expected FIC subjects (SAs↔UAMI); **fail on drift**.
  * Deny if startup evidence indicates alias mismatch.
* **Promotion**: MRMC approval gates; flip from Eval to Serve by redeploying API with **production-only** policy.

**Helm values (skeleton)**

```yaml
stage: serving
uamiClientId: "<GUID-UAMI-SERVE>"
aliasPolicy:
  allowedAliases: ["production-*"]

apim:
  routes:
    - "^/predict$"
    - "^/batch$"
    - "^/api/messages$"
    - "^/healthz$"
    - "^/readyz$"

egress:
  allow:
    - unityCatalog
    - datamesh.prod
    - kafka:
        topics: ["product.<id>.serve.in", "product.<id>.serve.out"]
    - observability
```

---

## 10) Observability & Evidence

* **Traces/metrics/logs** tagged with `product_id, api_id, stage, uami_id, family_id, model_id, model_version, alias, request_id`.
* **Startup evidence blob** (JSON) includes:

  * Stage policy id, allowed aliases, UC resolution results (families → version ids), artifact digests/signatures, decision.
* **APIM decision logs** (route id, required groups/roles, Graph correlation id, decision).
* **Bundle roll-up**: Version → Family → **Stage** → **AI-Product**.

---

## 11) Security & Risk Controls

* **Default-deny egress**; explicit allowlists per stage.
* **Istio mTLS** everywhere; named ports (`http`, `grpc`) for routing determinism.
* **JWT validation at APIM**; optional Graph lookups for nested/overage groups.
* **No token fan-out**; API uses stage UAMI for A2A/service calls.
* **Data residency & retention** enforced via MRMC profile per stage (e.g., eval datasets vs prod sources).

---

## 12) Failure Modes & Responses

| Failure                            | Detection                                   | Response                                                   |
| ---------------------------------- | ------------------------------------------- | ---------------------------------------------------------- |
| Alias mismatch at startup          | API exits non-zero; readiness never green   | Roll back release; fix UC alias or policy; redeploy        |
| Artifact digest/signature mismatch | Startup evidence shows verification failure | Quarantine artifacts; re-publish signed bundle; redeploy   |
| APIM policy misconfig (denies)     | 401/403 at edge                             | Correct APIM product/policy; redeploy if route set changes |
| UAMI federation drift              | CI/CD FIC drift check fails                 | Correct SA↔UAMI bindings; re-apply workload identity       |
| Egress denial                      | Istio deny logs                             | Update allowlist; MRMC sign-off if new destination         |

---

## 13) Split Criteria (stay one AI-Product or split?)

Split into **multiple AI-Products** if any of the following differ and cannot be reconciled:

* UAMI or AAD group model
* MRMC profile (PII class, residency, retention)
* UC schema ownership or data scope
* Ingress/egress policies or Kafka topic boundaries
* Audit requirements or ops/SLO envelope
* Cost center / business ownership

---

# Appendices

## Appendix A — Info-Ports Contract

* **GET /info/agent** → stage, UAMI id, API id/version
* **GET /info/model-card** → `{ family, alias, version, digests, timestamp }[]` (materialized set)
* **GET /info/aibom** → aggregated SBOM/AI-BOM across materialized models
* **Security**: APIM Viewer group only; cacheable; optional response signing

## Appendix D — MRMC Gate (checklist)

* Alias-conformance evidence present and signed/hashed.
* Evaluation metrics & safety tests meet thresholds.
* Data residency/retention aligned with stage.
* Supply chain: SBOM, signatures, provenance verified.
* Egress allowlists match declared sources/destinations.
* Rollback & incident playbook validated.
